import logging
import os
from datetime import datetime
from pathlib import Path
from threading import Lock
from typing import Any, Dict, Generator, List, Optional
from urllib import parse

import dicttoxml
import draymed
import kombu_batteries_included
import pdfkit
import pytz
import requests
from flask import Response, current_app
from flask_batteries_included.helpers.error_handler import ServiceUnavailableException
from flask_batteries_included.sqldb import db, generate_uuid
from jinja2 import Environment, PackageLoader
from requests import HTTPError
from she_logging import logger
from she_logging.request_id import current_request_id
from sqlalchemy.exc import IntegrityError

from dhos_pdf_api import trustomer
from dhos_pdf_api.blueprint_api.hl7_cda import create_hl7_cda_xml
from dhos_pdf_api.blueprint_api.send_ward_report import (
    SendWardReportReader,
    SendWardReportWriter,
)
from dhos_pdf_api.models.filename_lookup import FilenameLookup

from .helpers import (
    PDF_DATETIME_FORMAT,
    format_iso8601_datestring_to_pdf_format,
    get_iso_format_time_now,
    value_or_none,
    write_file,
    xml_datetime_convert,
    xml_opt_datetime_convert,
    yes_no_not_specified,
)

dicttoxml.LOG.setLevel(logging.ERROR)
env = Environment(autoescape=True, loader=PackageLoader("dhos_pdf_api", "templates"))
env.filters["yes_no_not_specified"] = yes_no_not_specified
env.filters[
    "format_iso8601_datestring_to_pdf_format"
] = format_iso8601_datestring_to_pdf_format
env.filters["value_or_none"] = value_or_none
template = {
    "gdm": env.get_template("gdm_181_patient.html"),
    "dbm": env.get_template("dbm_patient.html"),
}

report_writer_lock: Lock = Lock()


def request_headers() -> Dict:
    return {"X-Request-ID": current_request_id()}


def create_patient_pdf(data: Dict, product_name: str) -> None:
    output_dir: str = _get_output_dir(product_name=product_name)

    # NOT utcnow, because this should reflect daylight savings
    now: datetime = datetime.now(
        tz=pytz.timezone(current_app.config["SERVER_TIMEZONE"])
    )
    now_string: str = now.strftime(PDF_DATETIME_FORMAT)

    patient_uuid: str = data["patient"]["uuid"]
    first_name: str = data["patient"]["first_name"]
    last_name: str = data["patient"]["last_name"]
    nhs_number: str = data["patient"]["nhs_number"]
    hospital_number: str = data["patient"]["hospital_number"]

    product_name_header = product_name.upper()
    if product_name_header == "GDM":
        product_name_header = "GDm-Health"
    elif product_name_header == "DBM":
        product_name_header = "DBm-Health"
    else:
        raise ValueError("Unknown product '%s'", product_name_header)

    logger.info(f"Generating {product_name_header} PDF for {patient_uuid}")
    logger.debug(f"PDF data {data}")

    # Do the deed
    pdf = pdfkit.from_string(
        template[product_name].render(**data),
        False,
        options={
            "--footer-center": f"Generated by the Sensyne Health {product_name_header} system on {now_string}",
            "--footer-font-size": "11",
            "--footer-font-name": "OpenSans",
            "--header-left": f"{product_name_header} patient record for {first_name} {last_name.upper()}",
            "--header-right": "Page [page] of [toPage]",
            "--header-line": "",
            "--header-spacing": "4",
            "--header-font-size": "11",
            "--header-font-name": "OpenSans",
        },
    )

    # Save PDF to file.
    directory: Path = Path(current_app.config[output_dir])
    directory.mkdir(exist_ok=True)
    pdf_filename = (
        parse.quote_plus(f"{first_name}-{last_name}-{nhs_number or hospital_number}")
        + ".pdf"
    )
    pdf_destination: Path = directory / pdf_filename

    if pdf_destination.parent != directory:
        raise ValueError(f"Invalid `pdf_filename` value: `{pdf_filename}`")

    pdf_destination.write_bytes(pdf)
    logger.debug(f"Wrote {product_name} BCP PDF to file: {pdf_destination}")

    # Save the filename in the database.
    _save_filename_lookup(lookup_uuid=patient_uuid, file_name=pdf_filename)


def _get_output_dir(product_name: str) -> str:
    if product_name == "gdm":
        return "GDM_BCP_OUTPUT_DIR"
    if product_name == "dbm":
        return "DBM_BCP_OUTPUT_DIR"

    raise ValueError(f"Product {product_name} is not supported")


def get_patient_pdf(patient_uuid: str, product_name: str) -> bytes:
    output_dir: str = _get_output_dir(product_name=product_name)
    logger.debug(f"Getting latest {product_name} PDF for patient: {patient_uuid}")
    lookup: FilenameLookup = FilenameLookup.query.filter_by(
        lookup_uuid=patient_uuid
    ).first_or_404()
    path: Path = Path(current_app.config[output_dir]) / lookup.file_name
    return path.read_bytes()


def pdf_stream(
    pdf_bytes: bytes, chunk_size: int = 10 * 1024, mimetype: str = "application/pdf"
) -> Response:
    logger.debug("Streaming PDF")

    def stream(content: bytes) -> Generator[bytes, None, None]:
        index = 0
        while True:
            if index >= len(content):
                break
            yield content[index : index + chunk_size]
            index += chunk_size

    return Response(stream(pdf_bytes), status=200, mimetype=mimetype)


def get_send_pdf(encounter_uuid: str) -> bytes:
    logger.debug("Getting latest SEND PDF for encounter: %s", encounter_uuid)
    lookup = FilenameLookup.query.filter_by(lookup_uuid=encounter_uuid).first_or_404()
    path: Path = Path(current_app.config["SEND_BCP_OUTPUT_DIR"]) / lookup.file_name
    return path.read_bytes()


def generate_send_pdf(data: dict) -> bytes:
    logger.debug("Generating SEND PDF for encounter %s", data["encounter"]["uuid"])
    url: str = f"{current_app.config['DHOS_PDF_ENGINE_URL']}/dhos/v1/send_pdf"
    try:
        response = requests.post(url, headers=request_headers(), json=data)
        response.raise_for_status()

    except requests.exceptions.ConnectionError as e:
        logger.exception("Could not connect to PDF engine")
        raise ServiceUnavailableException(e)

    except HTTPError as e:
        logger.exception("HTTP error running PDF engine")
        raise ServiceUnavailableException(e)

    logger.debug("Received result from PDF engine")
    return response.content


def create_send_documents(send_data: dict) -> None:
    # Add trustomer config from redis, and validate the incoming data
    send_data["trustomer"] = trustomer.get_trustomer_config()

    # If the SEND data includes no obs sets or Score system changes, don't generate the PDF as it would be empty.
    observation_sets: List[Dict] = send_data["observation_sets"]
    score_system_changes: List[Dict] = send_data["encounter"].get(
        "score_system_history", []
    )
    if len(observation_sets) == 0 and len(score_system_changes) == 0:
        logger.info(
            "Skipping SEND document generation, no obs sets or Score system changes"
        )
        return

    # Generate the BCP PDF bytes
    pdf: bytes = generate_send_pdf(send_data)

    # Generate filename
    patient_mrn: str = send_data["patient"].get("hospital_number")
    patient_nhs: str = send_data["patient"].get("nhs_number")
    epr_encounter_id: str = send_data["encounter"].get("epr_encounter_id")
    encounter_uuid: str = send_data["encounter"].get("uuid")

    filename: str = parse.quote_plus(
        f"{patient_mrn or patient_nhs}-{epr_encounter_id or encounter_uuid}"
    )
    pdf_filename = filename + ".pdf"

    # Make dir if it doesn't already exist
    directory: str = os.path.abspath(current_app.config["SEND_BCP_OUTPUT_DIR"])
    pdf_destination = os.path.join(directory, pdf_filename)

    # Make RSYNC dir if it doesn't already exist
    rsync_directory: str = os.path.abspath(current_app.config["SEND_BCP_RSYNC_DIR"])
    rsync_pdf_destination = os.path.join(rsync_directory, pdf_filename)

    # Write PDF to file.
    logger.info("Writing SEND PDFs")

    write_file(pdf_destination, pdf)
    logger.debug("File written to destination: %s", pdf_destination)

    write_file(rsync_pdf_destination, pdf)
    logger.debug("File written to destination: %s", rsync_pdf_destination)

    # Save the filename in the database.
    _save_filename_lookup(lookup_uuid=encounter_uuid, file_name=pdf_filename)

    cda_unc_path: Optional[str] = current_app.config.get("SEND_BCP_CDA_UNC_PATH", None)
    if cda_unc_path:
        publish_hl7_cda_xml(send_data, cda_unc_path, pdf_filename)

    if not send_data["encounter"].get("discharged_at"):
        return

    # Check for discharge document generation
    discharge_dest: str = current_app.config["SEND_DISCHARGE_OUTPUT_DIR"]
    if not discharge_dest:
        return

    # Write duplicate PDF
    pdf_discharge_dest: str = os.path.join(discharge_dest, pdf_filename)
    write_file(pdf_discharge_dest, pdf)
    # Write XML file
    xml_discharge_dest = os.path.join(discharge_dest, filename + ".xml")

    send_data["pdf_filename"] = pdf_filename
    send_data["encounter_id"] = epr_encounter_id or encounter_uuid
    xml: bytes = create_pdf_metadata_xml(send_data)
    write_file(xml_discharge_dest, xml)


def create_pdf_metadata_xml(data: dict) -> bytes:
    encounter: dict = data.get("encounter", {})
    patient: Dict[str, Any] = data.get("patient", {})
    sex: Optional[str] = patient.get("sex")
    patient_gender: str = "Unknown"
    if sex is not None:
        patient_gender = draymed.codes.description_from_code(
            sex, category="sex"
        ).title()

    full_data: dict = {
        "Docinfo": {
            "ExternalReferenceNumber": data.get("encounter_id"),
            "Documentfilename": data.get("pdf_filename"),
            "DocumentTypeCode": "01",
            "DocumentCreatedDateTime": xml_datetime_convert(get_iso_format_time_now()),
            "DocumentAuthor": "SEND",
        },
        "PatientInfo": {
            "PatientEpisodeId": data.get("encounter_id"),
            "PatientForename": patient.get("first_name"),
            "PatientSurname": patient.get("last_name"),
            "PatientDOB": xml_opt_datetime_convert(patient.get("dob")),
            "PatientNHSNumber": patient.get("nhs_number"),
            "PatientURNumber": patient.get("hospital_number"),
            "PatientGender": patient_gender,
            "PatientAdmissionDateTime": xml_opt_datetime_convert(
                encounter.get("admitted_at")
            ),
            "PatientDischargeDateTime": xml_opt_datetime_convert(
                encounter.get("discharged_at")
            ),
            "SpecialtyCode": "",
            "SpecialtyName": "",
        },
        "GPPractice": {"PracticeName": "", "GpName": "", "PracticeNacsCode": ""},
    }

    xml: bytes = dicttoxml.dicttoxml(full_data, attr_type=False, root=False)
    logger.debug("Created PDF metadata")
    return b'<xml version="1.0" encoding="UTF-8" >' + xml + b"</xml>"


def generate_send_ward_report_pdf(data: dict, ward_report_folder: Path) -> None:
    logger.info("Getting SEND ward report for location %s", data.get("location_uuid"))
    with report_writer_lock:
        return SendWardReportWriter(
            file_path=ward_report_folder / f"{data['location_uuid']}.pdf", **data
        ).write()


def get_send_ward_report_pdf(location_uuid: str, ward_report_folder: Path) -> bytes:
    logger.info("Getting SEND ward report for location %s", location_uuid)
    reader = SendWardReportReader(file_path=ward_report_folder / f"{location_uuid}.pdf")
    return reader.read()


def _save_filename_lookup(lookup_uuid: str, file_name: str) -> None:
    """
    Creates the filename lookup in the database, saving or updating as necessary.
    """
    existing_lookup: Optional[FilenameLookup] = FilenameLookup.query.filter_by(
        lookup_uuid=lookup_uuid
    ).first()
    if existing_lookup is None:
        _create_new_filename_lookup(lookup_uuid=lookup_uuid, file_name=file_name)
    else:
        logger.debug("Updating existing FilenameLookup")
        existing_lookup.file_name = file_name
        db.session.commit()


def _create_new_filename_lookup(lookup_uuid: str, file_name: str) -> None:
    # Guard against race condition caused by simultaneous lookup creation in another thread/pod.
    try:
        logger.debug("Creating new FilenameLookup")
        new_lookup: FilenameLookup = FilenameLookup(
            uuid=generate_uuid(), lookup_uuid=lookup_uuid, file_name=file_name
        )
        db.session.add(new_lookup)
        db.session.commit()
    except IntegrityError:
        # Since the check on line 292 the lookup has been created.
        db.session.rollback()
        logger.debug("Failed to create FilenameLookup")
        new_lookup = FilenameLookup.query.filter_by(
            lookup_uuid=lookup_uuid
        ).first_or_404()
        new_lookup.file_name = file_name
        db.session.commit()


def publish_hl7_cda_xml(data: Dict, base_unc_path: str, pdf_filename: str) -> None:
    parser: object = current_app.config["CDA_XML_SCHEMA_PARSER"]
    xml: bytes = create_hl7_cda_xml(data, base_unc_path, pdf_filename, parser)
    kombu_batteries_included.publish_message(
        routing_key="dhos.423779001", body={"content": xml.decode("utf-8")}
    )
